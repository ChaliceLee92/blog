---
title: 中级前端面试题收集
date: 2020-11-27 00:57:57
categories: 面试题
tags: 中级
---

## promise.all 和 promise.race 区别

promise.all :

```js
  比如当数组里的P1，P2都执行完成时，页面才显示。
  值得注意的是，返回的数组结果顺序不会改变，即使P2的返回要比P1的返回快，顺序依然是P1，P2
  Promise.all成功返回成功数组,
  失败返回失败数据,一但失败就不会继续往下走
```

promise.race :

```js
  Promise.race是赛跑的意思，也就是说Promise.race([p1, p2, p3])里面的结果哪个获取的快，就返回哪个结果，不管结果本身是成功还是失败
```

使用场景:
  Promise.all和Promise.race都是有使用场景的。
  有些时候我们做一个操作可能得同时需要不同的接口返回的数据，这时我们就可以使用Promise.all；
  有时我们比如说有好几个服务器的好几个接口都提供同样的服务，我们不知道哪个接口更快，就可以使用Promise.race，哪个接口的数据先回来我们就用哪个接口的数据。

## 哪些设计模式，用过哪些

1.工厂模式
2.单例模式
3.代理模式
4.观察者模式
5.策略模式

## http2.0和http1.1区别

1.多路复用
2.首部压缩
3.HTTP2支持服务器推送

## 如何并发请求

1.promise.all
2.axios.all 和 axios.spread

## 从输入url到页面加载全过程

1.DNS 解析:将域名解析成 IP 地址
2.TCP 连接：TCP 三次握手
3.发送 HTTP 请求
4.服务器处理请求并返回 HTTP 报文
5.浏览器解析渲染页面
6.断开连接：TCP 四次挥手

## 三次握手和四次挥手分别是什么

### 三次握手

1.第一次握手 ，客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。
2.第二次握手 ，服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。此时服务器处于 SYN_RCVD 的状态。
3.第三次握手 ，客户端收到 SYN 报文之后，会发送一个 ACK 报文，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

### 为什么需要三次握手，两次不行吗

第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

### 四次挥手

第一次挥手：客户端发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
第二次挥手：服务端收到连接释放报文段后即发出确认报文段，服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
第三次挥手：服务端没有要向客户端发出的数据，服务端发出连接释放报文段，服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
第四次挥手：客户端收到服务端的连接释放报文段后，对此发出确认报文段，客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

### 挥手为什么需要四次

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

### 四次挥手释放连接时，等待2MSL的意义

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

## http和https的区别

1.https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2.http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 为什么定时器是不精准的

因为 JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。
为了控制要执行的代码，就有一个 JavaScript 任务队列。
这些任务会按照将它们添加到队列的顺序执行。
setTimeout() 的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行

## 什么是mvvm,mvc

MVVM 是 Model View ViewModel 的缩写 , 是由 MVC 中的 controller 演变而来。
Model 层代表 数据 ； View 层代表 视图 ； ViewModel 层是 View 和 Model 之间的桥梁； 数据会绑定到ViewModel层并自动将数据渲染到页面中；视图变化的时候会通知ViewModel 更新数据。

MVC 是 Model View Controller 的缩写 ， 是应用最广泛的软件架构之一。
View 一般用 Controller 来和 Model 进行联系。Controller是Model和View的协调者,View和Model不直接联系。基本都是单向联系。

## Mvvm的优缺点

优点：
1.低耦合。 view 可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候 View 也可以不变。
2.可重用性。 可以把一些视图逻辑放在一个 ViewModel 里面， 让很多View重用这段视图逻辑。
3.独立开发。 开发者可以专注于业务逻辑和数据的开发，设计人员可以专注于页面的设计。
4.可测试性。 开发者更好地编写测试代码自动更新dom

缺点：
1.bug定位调试困难。一个bug出现，有可能是View出现问题也有可能是Model出现问题。
2.一个大模块中Model也会很大，当时长期持有，不释放内存就造成了花费更多的内存对于大型的图形应用程序。
3.视图状态较多，ViewModel的构建和维护的成本都会比较高。

## Mvc的优缺点

优点：
1.可定制性。
2.代码清晰，便于维护。
3.视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。
4.潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中

缺点：
1.MVC 框架的大部分逻辑都集中在 Controller 层，代码量也都集中在 Controller 层，这带给 Controller 层很大的压力，而已经有独立处理事件能力的 View 层却没有用到。
2.还有一个问题，就是 Controller 层和 View 层之间是一一对应的，断绝了 View 层复用的可能，因而产生了很多冗余代码。

## Mvvm和Mvc的区别

1.MVC中Controller演变成MVVM中的ViewModel
2.MVVM通过数据来显示视图层而不是节点操作
3.MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验

## 原型和原型链

原型：
1.所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象
2.所有函数都有一个prototype(原型)属性，属性值是一个普通的对象
3.所有引用类型的__proto__属性指向它构造函数的prototype

原型链：
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

## 什么是同源策略，跨域的解决方法

同源： 若地址里面的协议、域名和端口号均相同则属于同源。

什么是同源策略？
同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。

什么是跨域？
受前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。

跨域的解决方法：
1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

## 前端性能优化

1.减少 HTTP 请求
2.使用 HTTP2
3.使用服务端渲染
4.静态资源使用 CDN
5.将 CSS 放在文件头部，JavaScript 文件放在底部
6.使用字体图标 iconfont 代替图片图标
7.善用缓存，不重复加载相同的资源
8.压缩文件
9.图片优化
10.通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
11.减少重绘重排
12.使用事件委托
13.注意程序的局部性
14.if-else 对比 switch

## 介绍虚拟Dom

虚拟Dom(Virtual DOM)是对DOM的抽象,本质上是JavaScript对象,这个对象就是更加轻量级的对DOM的描述.

前端性能优化的一个秘诀就是尽量少地操做DOM,不只仅是DOM相对较慢,更由于频繁变更DOM会形成浏览器的回流或者重回,这些都是性能的杀手,所以咱们须要这一层抽象,在patch过程当中尽量地一次性将差别更新到DOM中,这样保证了DOM不会出现性能不好的状况。
而且 虚拟dom 的最初目的就是更好的跨平台,好比Node.js就没有DOM,若是想实现SSR(服务端渲染),那么一个方式就是借助Virtual DOM,由于Virtual DOM自己是JavaScript对象.
