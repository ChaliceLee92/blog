---
title: 中级前端面试题收集
date: 2020-11-27 00:57:57
categories: 面试题
tags: 中级
---

## promise.all 和 promise.race 区别

promise.all :
比如当数组里的 P1，P2 都执行完成时，页面才显示。
值得注意的是，返回的数组结果顺序不会改变，即使 P2 的返回要比 P1 的返回快，顺序依然是 P1，P2
Promise.all 成功返回成功数组,
失败返回失败数据,一但失败就不会继续往下走

promise.race :
Promise.race 是赛跑的意思，也就是说 Promise.race([p1, p2, p3])里面的结果哪个获取的快，就返回哪个结果，不管结果本身是成功还是失败

使用场景:
Promise.all 和 Promise.race 都是有使用场景的。
有些时候我们做一个操作可能得同时需要不同的接口返回的数据，这时我们就可以使用 Promise.all；
有时我们比如说有好几个服务器的好几个接口都提供同样的服务，我们不知道哪个接口更快，就可以使用 Promise.race，哪个接口的数据先回来我们就用哪个接口的数据。

## 哪些设计模式，用过哪些

1. 工厂模式
2. 单例模式
3. 代理模式
4. 观察者模式
5. 策略模式

## http2.0 和 http1.1 区别

1. 多路复用
2. 首部压缩
3. HTTP2 支持服务器推送

## 如何并发请求

1. promise.all
2. axios.all 和 axios.spread

## 从输入 url 到页面加载全过程

1. DNS 解析:将域名解析成 IP 地址
2. TCP 连接：TCP 三次握手
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 断开连接：TCP 四次挥手

## 三次握手和四次挥手分别是什么

### 三次握手

1. 第一次握手 ，客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。
2. 第二次握手 ，服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。此时服务器处于 SYN_RCVD 的状态。
3. 第三次握手 ，客户端收到 SYN 报文之后，会发送一个 ACK 报文，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

### 为什么需要三次握手，两次不行吗

第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

### 四次挥手

第一次挥手：客户端发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。
第二次挥手：服务端收到连接释放报文段后即发出确认报文段，服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。
第三次挥手：服务端没有要向客户端发出的数据，服务端发出连接释放报文段，服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。
第四次挥手：客户端收到服务端的连接释放报文段后，对此发出确认报文段，客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

### 挥手为什么需要四次

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，"你发的 FIN 报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。

### 四次挥手释放连接时，等待 2MSL 的意义

为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。

## http 和 https 的区别

1. https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。
2. http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
3. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
4. http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

## 为什么定时器是不精准的

因为 JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。
为了控制要执行的代码，就有一个 JavaScript 任务队列。
这些任务会按照将它们添加到队列的顺序执行。
setTimeout() 的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行

## 什么是 mvvm,mvc

MVVM 是 Model View ViewModel 的缩写 , 是由 MVC 中的 controller 演变而来。
Model 层代表 数据 ； View 层代表 视图 ； ViewModel 层是 View 和 Model 之间的桥梁； 数据会绑定到 ViewModel 层并自动将数据渲染到页面中；视图变化的时候会通知 ViewModel 更新数据。

MVC 是 Model View Controller 的缩写 ， 是应用最广泛的软件架构之一。
View 一般用 Controller 来和 Model 进行联系。Controller 是 Model 和 View 的协调者,View 和 Model 不直接联系。基本都是单向联系。

## Mvvm 的优缺点

优点：

1. 低耦合。 view 可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。
2. 可重用性。 可以把一些视图逻辑放在一个 ViewModel 里面， 让很多 View 重用这段视图逻辑。
3. 独立开发。 开发者可以专注于业务逻辑和数据的开发，设计人员可以专注于页面的设计。
4. 可测试性。 开发者更好地编写测试代码自动更新 dom

缺点：

1. bug 定位调试困难。一个 bug 出现，有可能是 View 出现问题也有可能是 Model 出现问题。
2. 一个大模块中 Model 也会很大，当时长期持有，不释放内存就造成了花费更多的内存对于大型的图形应用程序。
3. 视图状态较多，ViewModel 的构建和维护的成本都会比较高。

## Mvc 的优缺点

优点：

1. 可定制性。
2. 代码清晰，便于维护。
3. 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象替换。
4. 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中

缺点：

1. MVC 框架的大部分逻辑都集中在 Controller 层，代码量也都集中在 Controller 层，这带给 Controller 层很大的压力，而已经有独立处理事件能力的 View 层却没有用到。
2. 还有一个问题，就是 Controller 层和 View 层之间是一一对应的，断绝了 View 层复用的可能，因而产生了很多冗余代码。

## Mvvm 和 Mvc 的区别

1. MVC 中 Controller 演变成 MVVM 中的 ViewModel
2. MVVM 通过数据来显示视图层而不是节点操作
3. MVVM 主要解决了 MVC 中大量的 dom 操作使页面渲染性能降低,加载速度变慢,影响用户体验

## 原型和原型链

原型：

1. 所有引用类型都有一个**proto**(隐式原型)属性，属性值是一个普通的对象
2. 所有函数都有一个 prototype(原型)属性，属性值是一个普通的对象
3. 所有引用类型的**proto**属性指向它构造函数的 prototype

原型链：
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的**proto**隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的**proto**中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

## 什么是同源策略，跨域的解决方法

同源： 若地址里面的协议、域名和端口号均相同则属于同源。

什么是同源策略？
同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。

什么是跨域？
受前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。

跨域的解决方法：

1. 通过 jsonp 跨域
2. document.domain + iframe 跨域
3. location.hash + iframe
4. window.name + iframe 跨域
5. postMessage 跨域
6. 跨域资源共享（CORS）
7. nginx 代理跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

## 前端性能优化

1. 减少 HTTP 请求
2. 使用 HTTP2
3. 使用服务端渲染
4. 静态资源使用 CDN
5. 将 CSS 放在文件头部，JavaScript 文件放在底部
6. 使用字体图标 iconfont 代替图片图标
7. 善用缓存，不重复加载相同的资源
8. 压缩文件
9. 图片优化
10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
11. 减少重绘重排
12. 使用事件委托
13. 注意程序的局部性
14. if-else 对比 switch

## 介绍虚拟 Dom

虚拟 Dom(Virtual DOM)是对 DOM 的抽象,本质上是 JavaScript 对象,这个对象就是更加轻量级的对 DOM 的描述.

前端性能优化的一个秘诀就是尽量少地操做 DOM,不只仅是 DOM 相对较慢,更由于频繁变更 DOM 会形成浏览器的回流或者重回,这些都是性能的杀手,所以咱们须要这一层抽象,在 patch 过程当中尽量地一次性将差别更新到 DOM 中,这样保证了 DOM 不会出现性能不好的状况。
而且 虚拟 dom 的最初目的就是更好的跨平台,好比 Node.js 就没有 DOM,若是想实现 SSR(服务端渲染),那么一个方式就是借助 Virtual DOM,由于 Virtual DOM 自己是 JavaScript 对象.

## 防抖和节流

### 防抖

概念：
触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间

实现思路：
每次触发事件时都取消之前的延时调用方法

```JavaScript
  function debounce(fn) {
    let timeout = null; // 创建一个标记用来存放定时器的返回值
    return function () {
      clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
      timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
        fn.apply(this, arguments);
      }, 500);
    };
  }
```

使用场景:
登录、发短信、表单重复提交等按钮，避免用户快速点击导致触发多次请求，需要防抖。
调整浏览器窗口大小时，resize 次数频繁

### 节流

概念:
高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率

实现思路:
每次触发事件时都判断当前是否有等待执行的延时函数

```JavaScript
  function throttle(fn) {
    let canRun = true; // 通过闭包保存一个标记
    return function () {
      if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
      canRun = false; // 立即设置为false
      setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
        fn.apply(this, arguments);
        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
        canRun = true;
      }, 500);
    };
  }
```

使用场景:
scroll 事件，每隔一秒计算一次位置信息
浏览器播放事件，每隔一秒计算一次进度信息
input 框实时搜索

## 浅拷贝和深拷贝，如何实现深拷贝

浅拷贝概念： 如果拷贝的属性是基本类型，拷贝的就是基本类型的值，如果拷贝的属性是引用类型，那么拷贝的就是内存地址。
深拷贝概念： 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一块内存空间存放新的对象。

它们之间的区别：
浅拷贝只是拷贝对象的内存地址，并不是堆中的数据，所以该对象如果改变了，那么通过浅拷贝操作的对象也会受到影响。
深拷贝拷贝的是堆内存中的数据，重新开辟一块空间来存放数据，所以该对象即使改变也不会影响到拷贝的对象。

浅拷贝的方法有:

1. Object.assign() ; 如果对象的属性值为简单类型（string， number），通过 Object.assign({}, Obj);得到的新对象为深拷贝；如果属性值为对象或其它引用类型，那对于这个对象而言其实是浅拷贝的。这是 Object.assign()特别值得注意的地方。

   ```JavaScript
     let a = {a : 'old', b : { c : 'old'}}
     let b = Object.assign({}, a)
     b.a = 'new'
     b.b.c = 'new'
     console.log(a) // { a: 'old', b: { c: 'new' } }
     console.log(b) // { a: 'new', b: { c: 'new' } }
   ```

2. Array.prototype.slice() ;该方法提取并返回一个新的数组 ， 如果源数组中的元素是个对象的引用，slice 会拷贝这个对象的引用到新的数组

   ```JavaScript
     let arr = ['a', 'b', {d: 'old'}]
     let arr1 = arr.slice(1)
     arr1[1].d = 'new'
     console.log(arr[2].d) // new
   ```

3. Array.prototype.concat() ; 该方法返回一个新的数组，和 slice 方法类似，当源数组中的元素是个对象的引用，concat 在合并时拷贝的就是这个对象的引用

   ```JavaScript
     let arr1 = [{a: 'old'}, 'b', 'c']
     let arr2 = [{b: 'old'}, 'd', 'e']
     let arr3 = arr1.concat(arr2)
     arr3[0].a = 'new'
     arr3[3].b = 'new'
     console.log(arr1[0].a) // new
     console.log(arr2[0].b) // new
   ```

4. 函数库 lodash 的\_.clone 方法
5. 展开运算符...

手动实现浅拷贝方法：
实现一个浅拷贝，就是遍历源对象，然后在将对象的属性的属性值都放到一个新对象里就 ok 了

```JavaScript
  function copy(obj) {
    if (!obj || typeof obj !== 'object') {
      return
    }

    let newObj = obj.constructor === Array ? [] : {}
    for (let key in obj) {
      newObj[key] = obj[key]
    }
    return newObj
  }
  let a = {b: 'bb', c: 'cc',  d: {e: 'ee'}}
  let b = copy(a)
  console.log(b) // { b: 'bb', c: 'cc', d: { e: 'ee' } }
```

深拷贝的方法有:

1. JSON.stringify()和 JSON.parse()的混合配对使用。 使用 JSON.stringify()和 JSON.parse()确实可以实现深拷贝 ， 但是如果源数据中假如出现 undefined、任意的函数以及 symbol 值的时候 JSON.stringify()在序列化过程中会被忽略。导致拷贝生成的对象中没有对应属性及属性值

   ```JavaScript
         let arr1 = [{a: 'old'}, 'b', 'c']
         let arr2 = [{b: 'old'}, 'd', 'e']
         let arr3 = arr1.concat(arr2)
         arr3[0].a = 'new'
         arr3[3].b = 'new'
         console.log(arr1[0].a) // new
         console.log(arr2[0].b) // new
   ```

2. 函数库 lodash 的\_.cloneDeep 方法
3. jQuery.extend()方法

手动实现深拷贝方法： 通过对需要拷贝的对象的属性进行递归遍历，如果对象的属性不是基本类型时，就继续递归，知道遍历到对象属性为基本类型，然后将属性和属性值赋给新对象。

```JavaScript
  function copy(obj) {
    if (!obj || typeof obj !== 'object') {
      return
    }
    var newObj = obj.constructor === Array ? [] : {}
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (typeof obj[key] === 'object') {
          newObj[key] = copy(obj[key])
        } else {
          newObj[key] = obj[key]
        }
      }
    }
    return newObj
  }

  var old = {a: 'old', b: {c: 'old'}}
  var newObj = copy(old)
  newObj.b.c = 'new'
  console.log(old) // { a: 'old', b: { c: 'old' } }
  console.log(newObj) // { a: 'old', b: { c: 'new' } }
```

深拷贝的需要考虑的东西不止于上面几行代码可以解决的，例如你还需要注意：

1. 入参类型检查
2. 当数据量较大并层次很深时，使用递归函数会导致栈溢出,而此处又无法使用尾递归,该怎么处理
3. typeof Date,Math,RegExp,Function,Null 都返回 Object 该怎么处理
4. Date,RegExp,Function 应该如何克隆
5. 当对象的两个属性 v,s 引用同一个对象时，克隆之后也应该引用同一个对象
6. 对象的原型 prototype 如何克隆
7. 属性的 getOwnPropertyDescriptor 如何克隆
8. for-in 遍历的是原型链，需要用 hasOwnProperty 判断是否是自有属性
9. 数组的兼容等...

## 介绍下浏览器缓存- 强缓存和协商缓存

1. 浏览器在加载资源时，根据请求头的 expires 和 cache-control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
2. 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 last-modified 和 etag 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
3. 如果前面两者都没有命中，直接从服务器加载资源

它们的相同点： 如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；

它们的不同点： 强缓存不发请求到服务器，协商缓存会发请求到服务器。

## 介绍下 http 状态码，304 是指什么

### http 状态码

1. 1xx 表示临时响应并需要请求者继续执行操作的状态码。
   | 状态码 | 解释 |
   | ---- | ---- |
   | 100（继续） | 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 |
   | 101（切换协议） | 请求者已要求服务器切换协议，服务器已确认并准备切换。 |
2. 2xx 表示成功处理了请求的状态码。
   | 状态码 | 解释 |
   | ---- | ---- |
   | 200（成功） | 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。 |
   | 201（已创建） | 请求成功并且服务器创建了新的资源。 |
   | 202（已接受） | 服务器已接受请求，但尚未处理。 |
   | 203（非授权信息） | 服务器已成功处理了请求，但返回的信息可能来自另一来源。 |
   | 204（无内容） | 服务器成功处理了请求，但没有返回任何内容。 |
   | 205（重置内容） | 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 |
   | 206（部分内容） | 服务器成功处理了部分 GET 请求。 |
3. 3xx （重定向） 通常，这些状态码用来重定向。
   | 状态码 | 解释 |
   | ---- | ---- |
   | 300（多种选择） | 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 |
   | 301（永久移动） | 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 |
   | 302（临时移动） | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 |
   | 303（查看其他位置） | 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 |
   | 304（未修改） | 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 |
   | 305（使用代理） | 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 |
   | 307（临时重定向） | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 |
4. 4xx（请求错误） 这些状态码表示请求可能出错，妨碍了服务器的处理。
   | 状态码 | 解释 |
   | ---- | ---- |
   | 400（错误请求） | 服务器不理解请求的语法。 |
   | 401（未授权） | 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 |
   | 403（禁止） | 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 |
   | 404（未找到） | 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 |
   | 405（方法禁用） | 禁用请求中指定的方法。 |
   | 406（不接受） | 无法使用请求的内容特性响应请求的网页。 |
   | 407（需要代理授权） | 此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 |
   | 408（请求超时） | 服务器等候请求时发生超时。 |
   | 409（冲突） | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 |
   | 410（已删除） | 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 |
   | 411（需要有效长度） | 服务器不接受不含有效内容长度标头字段的请求。 |
   | 412（未满足前提条件） | 服务器未满足请求者在请求中设置的其中一个前提条件。 |
   | 413（请求实体过大） | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 |
   | 414（请求的 URI 过长） | 请求的 URI（通常为网址）过长，服务器无法处理。 |
   | 415（不支持的媒体类型） | 请求的格式不受请求页面的支持。 |
   | 416（请求范围不符合要求） | 如果页面无法提供请求的范围，则服务器会返回此状态码。 |
   | 417（未满足期望值） | 服务器未满足”期望”请求标头字段的要求。 |
5. 5xx（服务器错误） 这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。
   | 状态码 | 解释 |
   | ---- | ---- |
   | 500（服务器内部错误） | 服务器遇到错误，无法完成请求。 |
   | 501（尚未实施） | 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 |
   | 502（错误网关） | 服务器作为网关或代理，从上游服务器收到无效响应。 |
   | 503（服务不可用） | 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 |
   | 504（网关超时） | 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 |
   | 505（HTTP 版本不受支持） | 服务器不支持请求中所用的 HTTP 协议版本。 |

### 304 是指什么

上面 304 状态码的解释是： 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
它其实就是浏览器的一种缓存机制, 第一次访问 服务器返回 200 ， 按 F5 进行页面刷新，返回 304，强制刷新浏览器， 再次返回 200

## 了解过前端工程化吗

个人理解的前端工程化 是使用软件工程的技术和方法来统一前端开发的流程 ，降低开发的成本，提高开发的效率。
以前的开发模式随着项目的复杂度跟多元化，开发成本跟维护成本都要求很高，前端开发者需要维护一大堆的文件，并且开发过程会显得很凌乱，文件耦合度高。
所以我认为的前端工程化应该从 模块化，组件化，规范化，自动化方面考虑。

1. 模块化： 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。
2. 组件化：从 UI 拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。
3. 规范化：规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。
4. 自动化：前端工程化的很多脏活累活都应该交给自动化工具来完成。

## 如何实现移动端的适配

1. 通过 meta 标签实现 ideal viewport
2. 通过 rem、vw、vh css 长度单位实现等比缩放
3. 缩放 init-sacle 的目的是解决 1px 的问题
4. 关于图片的最佳展示，是根据 dpr 去选择不同倍图

## webp 图文格式了解过吗

1. 2010 年谷歌推出的新一代图片格式
2. 保证图片质量的前提下缩小图片体积
3. 兼容性不太好 （苹果移动端不支持）
4. 移动应用或移动端网页游戏，界面需要大量图片，可以嵌入 webp 的解码包,能够节省用户流量，提升访问速度

## 数组里面有 10 万条数据，取第一个元素和第十万个元素时间相差多少

js 中所有得数组其实都是对象，数组可以直接根据索引取得对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)
得出结论：消耗时间几乎一致，差异可以忽略不计

## 如果要你手动实现一个懒加载你怎么实现

img src 为空，给一个 data-xx 属性存放图片真实地址，当页面滚动到图片可视区域时用 js 取值并赋值该图片

## 脚本攻击有哪些，如何防止

1. XSS (Cross Site Script) ，跨站脚本攻击

   ```JavaScript
     永远不要相信用户的输入，所有的输入都是有害的。
     跨站脚本是最常见的计算机安全漏洞，跨站脚本攻击指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入的恶意html代码会被执行，对受害用户可能采取Cookie资料窃取、会话劫持、钓鱼欺骗等各种攻击。

     解决办法：
       过滤用户的输入行为，将其转化为不被浏览器解释执行的字符
   ```

2. CSRF(Cross Site Request Forgery)，跨站点伪造请求。

   ```JavaScript
     CSRF攻击者通过各种方法伪造一个请求，模仿用户提交表单的行为，从而达到修改用户的数据，或者执行特定任务的目的。

     解决办法：
       1.采用POST请求,增加攻击的难度.用户点击一个链接就可以发起GET类型的请求。而POST请求相对比较难，攻击者往往需要借助javascript才能实现。
       2.对请求进行认证，确保该请求确实是用户本人填写表单并提交的，而不是第三者伪造的.具体可以在会话中增加token,确保看到信息和提交信息的是同一个人。（验证码）
   ```

3. Http Heads 攻击

   ```JavaScript
     HTTP协议在Response header和content之间，有一个空行，即两组CRLF（0x0D 0A）字符。这个空行标志着headers的结束和content的开始。“聪明”的攻击者可以利用这一点。只要攻击者有办法将任意字符“注入”到headers中，这种攻击就可以发生。

     解决办法：
       过滤所有的response headers，除去header中出现的非法字符，尤其是CRLF。
   ```

4. Cookie 攻击

   ```JavaScript
     通过Java Script非常容易访问到当前网站的cookie

     解决办法：
       增强cookie的安全性 ， 例如 给 cookie 打上标记
   ```

5. 重定向攻击

   ```JavaScript
     一种常用的攻击手段是“钓鱼”。钓鱼攻击者，通常会发送给受害者一个合法链接，当链接被点击时，用户被导向一个似是而非的非法网站，从而达到骗取用户信任、窃取用户资料的目的。为防止这种行为,我们必须对所有的重定向操作进行审核,以避免重定向到一个危险的地方.

     解决办法：
       常见解决方案是白名单,将合法的要重定向的url加到白名单中,非白名单上的域名重定向时拒之,第二种解决方案是重定向token,在合法的url上加上token,重定向时进行验证.
   ```

6. 上传文件攻击

   ```JavaScript
     1.文件名攻击
     上传的文件采用上传之前的文件名,可能造成:客户端和服务端字符码不兼容,导致文件名乱码问题;文件名包含脚本,从而造成攻击.
     2.文件后缀攻击
     上传的文件的后缀可能是exe可执行程序,js脚本等文件,这些程序可能被执行于受害者的客户端,甚至可能执行于服务器上.因此我们必须过滤文件名后缀,排除那些不被许可的文件名后缀.
     3.文件内容攻击
     IE6有一个很严重的问题 , 它，而是自动根据文件内容来识别文件的类型，并根据所识别的类型来显示或执行文件.如果上传一个gif文件,在文件末尾放一段js攻击脚本,就有可能被执行.这种攻击,它的文件名和content type看起来都是合法的gif图片,然而其内容却包含脚本,这样的攻击无法用文件名过滤来排除，而是必须扫描其文件内容，才能识别
   ```

7. DDos攻击

   ```JavaScript
     DDos攻击常见三种方式：
     1.SYN/ACK Flood攻击：
     这种攻击方法是经典最有效的DDOS攻击方法，可通杀各种系统的网络服务，主要是通过向受害主机发送大量伪造源IP和源端口的SYN（建立连接）或ACK（响应）包，导致主机的缓存资源被耗尽或忙于发送回应包而造成拒绝服务，由于源都是伪造的故追踪起来比较困难，缺点是实施起来有一定难度，需要高带宽的僵尸主机支持。少量的这种攻击会导致主机服务器无法访问，但却可以Ping的通，在服务器上用Netstat -na命令会观察到存在大量的SYN_RECEIVED状态，大量的这种攻击会导致Ping失败、TCP/IP栈失效，并会出现系统凝固现象，即不响应键盘和鼠标。普通防火墙大多无法抵御此种攻击。


     2.TCP全连接攻击：
     这种攻击是为了绕过常规防火墙的检查而设计的，一般情况下，常规防火墙大多具备过滤TearDrop、Land等DOS攻击的能力，但对于正常的TCP连接是放过的，殊不知很多网络服务程序（如：IIS、Apache等Web服务器）能接受的TCP连接数是有限的，一旦有大量的TCP连接，即便是正常的，也会导致网站访问非常缓慢甚至无法访问，TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的TCP连接，直到服务器的内存等资源被耗尽而被拖跨，从而造成拒绝服务，这种攻击的特点是可绕过一般防火墙的防护而达到攻击目的，缺点是需要找很多僵尸主机，并且由于僵尸主机的IP是暴露的，因此此种DDOS攻击方式容易被追踪。

     3.刷Script脚本攻击：
     这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，并调用MSSQLServer、MySQLServer、Oracle等数据库的网站系统而设计的，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用，典型的以小博大的攻击方法。一般来说，提交一个GET或POST指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是很大的，常见的数据库服务器很少能支持数百个查询指令同时执行，而这对于客户端来说却是轻而易举的，因此攻击者只需通过Proxy代理向主机服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务，常见的现象就是网站慢如蜗牛、ASP程序失效、PHP连接数据库失败、数据库主程序占用CPU偏高。这种攻击的特点是可以完全绕过普通的防火墙防护，轻松找一些Proxy代理就可实施攻击，缺点是对付只有静态页面的网站效果会大打折扣，并且有些Proxy会暴露DDOS攻击者的IP地址。
   ```
